structure Foo =
struct
  type t =
    { a: string
    , b: int
    , c: real
    , d: char
    , e: word
    , f: String.string
    , g: String.char
    , h: Int.int
    , i: Int32.int
    , j: Int64.int
    , k: LargeInt.int
    , l: FixedInt.int
    , m: Position.int
    , n: IntInf.int
    , o: Real.real
    , p: LargeReal.real
    , q: Char.char
    , r: Word.word
    , s: Word8.word
    , t: Word32.word
    , u: Word64.word
    , v: LargeWord.word
    , w: Date.date
    , x: CharVectorSlice.slice
    , y: Substring.substring
    , z: Time.time
    }
  val show =
    fn { a = t0
       , b = t1
       , c = t2
       , d = t3
       , e = t4
       , f = t5
       , g = t6
       , h = t7
       , i = t8
       , j = t9
       , k = t10
       , l = t11
       , m = t12
       , n = t13
       , o = t14
       , p = t15
       , q = t16
       , r = t17
       , s = t18
       , t = t19
       , u = t20
       , v = t21
       , w = t22
       , x = t23
       , y = t24
       , z = t25
       } =>
      "{"
      ^
      String.concatWith ", "
        [ "a = " ^ "\"" ^ t0 ^ "\""
        , "b = " ^ Int.toString t1
        , "c = " ^ Real.toString t2
        , "d = " ^ "#\"" ^ Char.toString t3 ^ "\""
        , "e = " ^ Word.toString t4
        , "f = " ^ "\"" ^ t5 ^ "\""
        , "g = " ^ "#\"" ^ Char.toString t6 ^ "\""
        , "h = " ^ Int.toString t7
        , "i = " ^ Int32.toString t8
        , "j = " ^ Int64.toString t9
        , "k = " ^ LargeInt.toString t10
        , "l = " ^ FixedInt.toString t11
        , "m = " ^ Position.toString t12
        , "n = " ^ IntInf.toString t13
        , "o = " ^ Real.toString t14
        , "p = " ^ LargeReal.toString t15
        , "q = " ^ "#\"" ^ Char.toString t16 ^ "\""
        , "r = " ^ Word.toString t17
        , "s = " ^ Word8.toString t18
        , "t = " ^ Word32.toString t19
        , "u = " ^ Word64.toString t20
        , "v = " ^ LargeWord.toString t21
        , "w = " ^ Date.toString t22
        , "x = " ^ Substring.string t23
        , "y = " ^ Substring.string t24
        , "z = " ^ Time.toString t25
        ] ^ "}"
  val compare =
    fn ( { a = t0
         , b = t1
         , c = t2
         , d = t3
         , e = t4
         , f = t5
         , g = t6
         , h = t7
         , i = t8
         , j = t9
         , k = t10
         , l = t11
         , m = t12
         , n = t13
         , o = t14
         , p = t15
         , q = t16
         , r = t17
         , s = t18
         , t = t19
         , u = t20
         , v = t21
         , w = t22
         , x = t23
         , y = t24
         , z = t25
         }
       , { a = t26
         , b = t27
         , c = t28
         , d = t29
         , e = t30
         , f = t31
         , g = t32
         , h = t33
         , i = t34
         , j = t35
         , k = t36
         , l = t37
         , m = t38
         , n = t39
         , o = t40
         , p = t41
         , q = t42
         , r = t43
         , s = t44
         , t = t45
         , u = t46
         , v = t47
         , w = t48
         , x = t49
         , y = t50
         , z = t51
         }
       ) =>
      (case String.compare (t0, t26) of
         EQUAL =>
           (case Int.compare (t1, t27) of
              EQUAL =>
                (case Real.compare (t2, t28) of
                   EQUAL =>
                     (case Char.compare (t3, t29) of
                        EQUAL =>
                          (case Word.compare (t4, t30) of
                             EQUAL =>
                               (case String.compare (t5, t31) of
                                  EQUAL =>
                                    (case Char.compare (t6, t32) of
                                       EQUAL =>
                                         (case Int.compare (t7, t33) of
                                            EQUAL =>
                                              (case Int32.compare (t8, t34) of
                                                 EQUAL =>
                                                   (case Int64.compare (t9, t35) of
                                                      EQUAL =>
                                                        (case
                                                           LargeInt.compare
                                                             (t10, t36)
                                                         of
                                                           EQUAL =>
                                                             (case
                                                                FixedInt.compare
                                                                  (t11, t37)
                                                              of
                                                                EQUAL =>
                                                                  (case
                                                                     Position.compare
                                                                       ( t12
                                                                       , t38
                                                                       )
                                                                   of
                                                                     EQUAL =>
                                                                       (case
                                                                          IntInf.compare
                                                                            ( t13
                                                                            , t39
                                                                            )
                                                                        of
                                                                          EQUAL =>
                                                                            (case
                                                                               Real.compare
                                                                                 ( t14
                                                                                 , t40
                                                                                 )
                                                                             of
                                                                               EQUAL =>
                                                                                 (case
                                                                                    LargeReal.compare
                                                                                      ( t15
                                                                                      , t41
                                                                                      )
                                                                                  of
                                                                                    EQUAL =>
                                                                                      (case
                                                                                         Char.compare
                                                                                           ( t16
                                                                                           , t42
                                                                                           )
                                                                                       of
                                                                                         EQUAL =>
                                                                                           (case
                                                                                              Word.compare
                                                                                                ( t17
                                                                                                , t43
                                                                                                )
                                                                                            of
                                                                                              EQUAL =>
                                                                                                (case
                                                                                                   Word8.compare
                                                                                                     ( t18
                                                                                                     , t44
                                                                                                     )
                                                                                                 of
                                                                                                   EQUAL =>
                                                                                                     (case
                                                                                                        Word32.compare
                                                                                                          ( t19
                                                                                                          , t45
                                                                                                          )
                                                                                                      of
                                                                                                        EQUAL =>
                                                                                                          (case
                                                                                                             Word64.compare
                                                                                                               ( t20
                                                                                                               , t46
                                                                                                               )
                                                                                                           of
                                                                                                             EQUAL =>
                                                                                                               (case
                                                                                                                  LargeWord.compare
                                                                                                                    ( t21
                                                                                                                    , t47
                                                                                                                    )
                                                                                                                of
                                                                                                                  EQUAL =>
                                                                                                                    (case
                                                                                                                       Date.compare
                                                                                                                         ( t22
                                                                                                                         , t48
                                                                                                                         )
                                                                                                                     of
                                                                                                                       EQUAL =>
                                                                                                                         (case
                                                                                                                            Substring.compare
                                                                                                                              ( t23
                                                                                                                              , t49
                                                                                                                              )
                                                                                                                          of
                                                                                                                            EQUAL =>
                                                                                                                              (case
                                                                                                                                 Substring.compare
                                                                                                                                   ( t24
                                                                                                                                   , t50
                                                                                                                                   )
                                                                                                                               of
                                                                                                                                 EQUAL =>
                                                                                                                                   Time.compare
                                                                                                                                     ( t25
                                                                                                                                     , t51
                                                                                                                                     )
                                                                                                                               | ? =>
                                                                                                                                   ?)
                                                                                                                          | ? =>
                                                                                                                              ?)
                                                                                                                     | ? =>
                                                                                                                         ?)
                                                                                                                | ? =>
                                                                                                                    ?)
                                                                                                           | ? =>
                                                                                                               ?)
                                                                                                      | ? =>
                                                                                                          ?)
                                                                                                 | ? =>
                                                                                                     ?)
                                                                                            | ? =>
                                                                                                ?)
                                                                                       | ? =>
                                                                                           ?)
                                                                                  | ? =>
                                                                                      ?)
                                                                             | ? =>
                                                                                 ?)
                                                                        | ? => ?)
                                                                   | ? => ?)
                                                              | ? => ?)
                                                         | ? => ?)
                                                    | ? => ?)
                                               | ? => ?)
                                          | ? => ?)
                                     | ? => ?)
                                | ? => ?)
                           | ? => ?)
                      | ? => ?)
                 | ? => ?)
            | ? => ?)
       | ? => ?)
  val op== =
    fn ( { a = t0
         , b = t1
         , c = t2
         , d = t3
         , e = t4
         , f = t5
         , g = t6
         , h = t7
         , i = t8
         , j = t9
         , k = t10
         , l = t11
         , m = t12
         , n = t13
         , o = t14
         , p = t15
         , q = t16
         , r = t17
         , s = t18
         , t = t19
         , u = t20
         , v = t21
         , w = t22
         , x = t23
         , y = t24
         , z = t25
         }
       , { a = t26
         , b = t27
         , c = t28
         , d = t29
         , e = t30
         , f = t31
         , g = t32
         , h = t33
         , i = t34
         , j = t35
         , k = t36
         , l = t37
         , m = t38
         , n = t39
         , o = t40
         , p = t41
         , q = t42
         , r = t43
         , s = t44
         , t = t45
         , u = t46
         , v = t47
         , w = t48
         , x = t49
         , y = t50
         , z = t51
         }
       ) =>
      t0 = t26 andalso t1 = t27 andalso Real.== (t2, t28) andalso t3 = t29
      andalso t4 = t30 andalso t5 = t31 andalso t6 = t32 andalso t7 = t33
      andalso t8 = t34 andalso t9 = t35 andalso t10 = t36 andalso t11 = t37
      andalso t12 = t38 andalso t13 = t39 andalso Real.== (t14, t40)
      andalso LargeReal.== (t15, t41) andalso t16 = t42 andalso t17 = t43
      andalso t18 = t44 andalso t19 = t45 andalso t20 = t46 andalso t21 = t47
      andalso Date.compare (t22, t48) = EQUAL
      andalso Substring.compare (t23, t49) = EQUAL
      andalso Substring.compare (t24, t50) = EQUAL andalso t25 = t51
  local
    val combine = fn (a, b) => 0w31 * a + b
    val hashString =
      #1
      o
      Substring.foldl
        (fn (ch, (h, p)) =>
           ( Word.mod (h + Word.fromInt (Char.ord ch + 1) * p, 0w1000000009)
           , Word.mod (p * 0w31, 0w1000000009)
           )) (0w0, 0w1) o Substring.full
    val hashPosition =
      case Position.precision of
        SOME p =>
          if p > Word.wordSize + 1 then
            (fn i =>
               Word.fromLargeInt (IntInf.xorb
                 (i, IntInf.~>> (i, Word.fromInt Word.wordSize))))
            o Position.toLarge
          else
            Word.fromInt o Position.toInt
      | NONE => hashString o Position.toString
    val hashFixedInt =
      case FixedInt.precision of
        SOME p =>
          if p > Word.wordSize + 1 then
            (fn i =>
               Word.fromLargeInt (IntInf.xorb
                 (i, IntInf.~>> (i, Word.fromInt Word.wordSize))))
            o FixedInt.toLarge
          else
            Word.fromInt o FixedInt.toInt
      | NONE => hashString o FixedInt.toString
    val hashIntInf =
      case IntInf.precision of
        SOME p =>
          if p > Word.wordSize + 1 then
            (fn i =>
               Word.fromLargeInt (IntInf.xorb
                 (i, IntInf.~>> (i, Word.fromInt Word.wordSize))))
            o IntInf.toLarge
          else
            Word.fromInt o IntInf.toInt
      | NONE => hashString o IntInf.toString
    val hashInt64 =
      case Int64.precision of
        SOME p =>
          if p > Word.wordSize + 1 then
            (fn i =>
               Word.fromLargeInt (IntInf.xorb
                 (i, IntInf.~>> (i, Word.fromInt Word.wordSize))))
            o Int64.toLarge
          else
            Word.fromInt o Int64.toInt
      | NONE => hashString o Int64.toString
    val hashInt32 =
      case Int32.precision of
        SOME p =>
          if p > Word.wordSize + 1 then
            (fn i =>
               Word.fromLargeInt (IntInf.xorb
                 (i, IntInf.~>> (i, Word.fromInt Word.wordSize))))
            o Int32.toLarge
          else
            Word.fromInt o Int32.toInt
      | NONE => hashString o Int32.toString
    val hashLargeInt =
      case LargeInt.precision of
        SOME p =>
          if p > Word.wordSize + 1 then
            (fn i =>
               Word.fromLargeInt (IntInf.xorb
                 (i, IntInf.~>> (i, Word.fromInt Word.wordSize))))
            o LargeInt.toLarge
          else
            Word.fromInt o LargeInt.toInt
      | NONE => hashString o LargeInt.toString
    val hashWord64 =
      if Word64.wordSize > Word.wordSize + 1 then
        Word.fromInt o Word64.toInt
        o (fn w => Word64.xorb (w, Word64.>> (w, Word.fromInt Word.wordSize)))
      else
        Word.fromInt o Word64.toInt
    val hashWord8 =
      if Word8.wordSize > Word.wordSize + 1 then
        Word.fromInt o Word8.toInt
        o (fn w => Word8.xorb (w, Word8.>> (w, Word.fromInt Word.wordSize)))
      else
        Word.fromInt o Word8.toInt
    val hashWord32 =
      if Word32.wordSize > Word.wordSize + 1 then
        Word.fromInt o Word32.toInt
        o (fn w => Word32.xorb (w, Word32.>> (w, Word.fromInt Word.wordSize)))
      else
        Word.fromInt o Word32.toInt
    val hashLargeWord =
      if LargeWord.wordSize > Word.wordSize + 1 then
        Word.fromInt o LargeWord.toInt
        o
        (fn w =>
           LargeWord.xorb (w, LargeWord.>> (w, Word.fromInt Word.wordSize)))
      else
        Word.fromInt o LargeWord.toInt
  in
    val hash =
      fn { a = t0
         , b = t1
         , c = t2
         , d = t3
         , e = t4
         , f = t5
         , g = t6
         , h = t7
         , i = t8
         , j = t9
         , k = t10
         , l = t11
         , m = t12
         , n = t13
         , o = t14
         , p = t15
         , q = t16
         , r = t17
         , s = t18
         , t = t19
         , u = t20
         , v = t21
         , w = t22
         , x = t23
         , y = t24
         , z = t25
         } =>
        let
          val result = hashString t0
          val result = combine (result, Word.fromInt t1)
          val result = combine (result, hashString (Real.toString t2))
          val result = combine (result, Word.fromInt (Char.ord t3))
          val result = combine (result, t4)
          val result = combine (result, hashString t5)
          val result = combine (result, Word.fromInt (Char.ord t6))
          val result = combine (result, Word.fromInt t7)
          val result = combine (result, hashInt32 t8)
          val result = combine (result, hashInt64 t9)
          val result = combine (result, hashLargeInt t10)
          val result = combine (result, hashFixedInt t11)
          val result = combine (result, hashPosition t12)
          val result = combine (result, hashIntInf t13)
          val result = combine (result, hashString (Real.toString t14))
          val result = combine (result, hashString (LargeReal.toString t15))
          val result = combine (result, Word.fromInt (Char.ord t16))
          val result = combine (result, t17)
          val result = combine (result, hashWord8 t18)
          val result = combine (result, hashWord32 t19)
          val result = combine (result, hashWord64 t20)
          val result = combine (result, hashLargeWord t21)
          val result = combine (result, hashString (Date.toString t22))
          val result = combine (result, hashString (Substring.string t23))
          val result = combine (result, hashString (Substring.string t24))
          val result = combine (result, hashString (Time.toString t25))
        in
          result
        end
  end
end

datatype test_hash = Foo of int * string | Bar of {a: int, b: string}
local
  val combine = fn (a, b) => 0w31 * a + b
  val hashString =
    #1
    o
    Substring.foldl
      (fn (ch, (h, p)) =>
         ( Word.mod (h + Word.fromInt (Char.ord ch + 1) * p, 0w1000000009)
         , Word.mod (p * 0w31, 0w1000000009)
         )) (0w0, 0w1) o Substring.full
in
  val hashTest_hash =
    fn Foo (t0, t1) =>
      let
        val result = hashString "Foo"
        val result = combine (result, Word.fromInt t0)
        val result = combine (result, hashString t1)
      in
        result
      end
     | Bar {a = t2, b = t3} =>
      let
        val result = hashString "Bar"
        val result = combine (result, Word.fromInt t2)
        val result = combine (result, hashString t3)
      in
        result
      end
end

structure Bar =
struct
  type t =
    { a: Bool.bool Option.option
    , b: Char.char List.list
    , c: int ref
    , d: Foo.t
    , e: unit
    }
  local
    fun showOption f (SOME s) = "SOME " ^ f s
      | showOption _ NONE = "NONE"
  in
    val show = fn {a = t0, b = t1, c = ref t2, d = t3, e = _} =>
      "{"
      ^
      String.concatWith ", "
        [ "a = " ^ showOption Bool.toString t0
        , "b = "
          ^
          "["
          ^
          String.concatWith ", "
            (List.map (fn t0 => "#\"" ^ Char.toString t0 ^ "\"") t1) ^ "]"
        , "c = " ^ "ref " ^ Int.toString t2
        , "d = " ^ Foo.show t3
        , "e = " ^ "()"
        ] ^ "}"
  end
  local
    fun compareBool (false, true) = LESS
      | compareBool (true, false) = GREATER
      | compareBool (_, _) = EQUAL
    fun compareList cmp (x :: xs, y :: ys) =
          (case cmp (x, y) of
             EQUAL => compareList cmp (xs, ys)
           | ? => ?)
      | compareList _ (_ :: _, []) = GREATER
      | compareList _ ([], _ :: _) = LESS
      | compareList _ _ = EQUAL
    fun compareOption cmp (SOME x, SOME y) = cmp (x, y)
      | compareOption _ (SOME _, NONE) = GREATER
      | compareOption _ (NONE, SOME _) = LESS
      | compareOption _ (NONE, NONE) = EQUAL
  in
    val compare =
      fn ( {a = t0, b = t1, c = ref t2, d = t3, e = _}
         , {a = t4, b = t5, c = ref t6, d = t7, e = _}
         ) =>
        (case compareOption compareBool (t0, t4) of
           EQUAL =>
             (case compareList Char.compare (t1, t5) of
                EQUAL =>
                  (case Int.compare (t2, t6) of
                     EQUAL => Foo.compare (t3, t7)
                   | ? => ?)
              | ? => ?)
         | ? => ?)
  end
  local
    fun eqList eq (x :: xs, y :: ys) =
          eq (x, y) andalso eqList eq (xs, ys)
      | eqList _ ([], []) = true
      | eqList _ _ = false
    fun eqOption eq (SOME x, SOME y) = eq (x, y)
      | eqOption _ (NONE, NONE) = true
      | eqOption _ _ = false
  in
    val op== =
      fn ( {a = t0, b = t1, c = t2, d = t3, e = _}
         , {a = t4, b = t5, c = t6, d = t7, e = _}
         ) =>
        eqOption op= (t0, t4) andalso eqList op= (t1, t5) andalso t2 = t6
        andalso Foo.== (t3, t7)
  end
  local
    val combine = fn (a, b) => 0w31 * a + b
    fun hashOption hash opt =
      Option.getOpt (Option.map hash opt, 0wx1A35B599)
    fun hashList _ [] = 0wx6D52A54D
      | hashList hash l =
          List.foldl (fn (i, acc) => combine (acc, hash i))
            (Word.fromInt (List.length l)) l
  in
    val hash = fn {a = t0, b = t1, c = ref t2, d = t3, e = _} =>
      let
        val result =
          hashOption (fn t0 => if t0 then 0wx096DB16D else 0wx01B56B6D) t0
        val result = combine
          (result, hashList (fn t0 => Word.fromInt (Char.ord t0)) t1)
        val result = combine (result, Word.fromInt t2)
        val result = combine (result, Foo.hash t3)
        val result = combine (result, 0wx65B2531B)
      in
        result
      end
  end
  type bar = unit
  val showBar = fn _ => "()"
  val compareBar = fn (_, _) => EQUAL
  val eqBar = fn (_, _) => true
  datatype bar = Bar of unit
  val showBar = fn Bar _ => "Bar " ^ "(" ^ "()" ^ ")"
  val compareBar = fn (Bar _, Bar _) => EQUAL
  val eqBar = fn (Bar _, Bar _) => true
end